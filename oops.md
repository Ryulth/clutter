객체지향의 장점

최초에는 많은 노력이 들어갈 수 있지만 프로그램을 상대적으로 쉽게 수정 할 수 있는 유연함을 제공한다. 변화된 요구사항을 빠르게 반영할 수 있다.

객체의 핵심은 기능을 제공하는 것



## 캡슐화

캡슐화는 객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것

기능 중심적으로 생각하자

또한 데이터를 체크하는 로직이라면 데이터를 가진 객체에게 기능을 요구해야한다.

데미테르의 법칙

- 메서드에서 생성한 객체의 메서드만 호출
- 파라미터(인자값) 으로 받은 객체의 메서드만 호출
- 필드로 참조하는 객체의 메서드만 호출

```java
public void something(Member member){
    if(member.getDate().getTime()<){
        // 이건 법칙을 어긴것
        // 인자로 받은 member의 메서드를 호출했지만 호출뒤 Date 객체의 getTime() 메서드를 호출함 즉 데이터를 접근하게 하도록 함
    }
}
```

제일 큰 증상은 get 의 중첩이다 get 의 중첩이 있다면 바로 확인해보라



## 다형성

이름부터 Polymorphism 여러(poly) 모습(morph) 이다. 한 객체가 여러 타입을 가질 수 있다는 것

책임을 계산해보고 많으면 분리한다

또한 개발시 확정성에 대한 확신을 할 수 없기 떄문에 추가적은 요구사항이 변경되는 로직은 차후에도 추가적인 변경이 있을 가능성이 큼으로 다형성으로 구현한다.



상속을 남용하면 안댐 상속은 IS - A 관계이어야한다

상속은 재사용성이아닌 확장에 사용해라





## SOLID

S : Single responsibility principle (단일 책임 원칙)

O : Open-closed principle (개방 폐쇠 원칙)

L : Liskov substitution principle (리스코프 치환 원칙)

I : Interface segregation principle (인터페이스 분리 원칙) 

D : Dependency inversion principle (의존 역전 원칙)

### 단일 책임 원칙

- 클래스는 단 한 개의 책임을 가져야 한다.

여러개의 책임을 갖게 되면 그 클래스는 각 책임마다 변경되는 이유가 발생하기 때문이다. 따라서 `클래스를 변경하는 이유는 단 한 개여야한다` 를 만족시킬 수 있도록 해야한다.

서로 다른 이유로 바뀌는 책임들이 한 클래스에 함께 포함되어 있다면 단일 책임 원칙을 어기고 있다.

처음 개발시 지키기 어렵다. 판단하기에 도움을 주는 방법은 `메서드를 실행하는 것이 누구인지 확인`하는 것 이다.

